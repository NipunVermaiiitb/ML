import pandas as pd
import numpy as np
from sklearn.linear_model import LassoCV
from sklearn.model_selection import KFold
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline

# ================== LOAD TRAIN DATA ==================
train = pd.read_csv('/kaggle/input/Medical-Equipments-Cost-Prediction-Challenge/train.csv')
target_col = 'Transport_Cost'

# ================== COMPUTE DAYS_BETWEEN_ORDER_DELIVERY ==================
train['Order_Placed_Date'] = pd.to_datetime(train['Order_Placed_Date'], format='%m/%d/%y', errors='coerce')
train['Delivery_Date'] = pd.to_datetime(train['Delivery_Date'], format='%m/%d/%y', errors='coerce')
train['Days_Between_Order_Delivery'] = (train['Delivery_Date'] - train['Order_Placed_Date']).dt.days

# Keep only rows with valid Transport_Cost (no negatives)
train = train[train[target_col] >= 0]

# Replace negative or missing Days_Between_Order_Delivery with median
median_days = train['Days_Between_Order_Delivery'].median()
train.loc[train['Days_Between_Order_Delivery'] < 0, 'Days_Between_Order_Delivery'] = median_days
train['Days_Between_Order_Delivery'] = train['Days_Between_Order_Delivery'].fillna(median_days).astype(int)

# ================== DROP UNNECESSARY COLUMNS ==================
drop_cols = ['Hospital_Id', 'Hospital_Location', 'Order_Placed_Date', 'Delivery_Date', 'Supplier_Name']
train = train.drop(columns=drop_cols, errors='ignore')

# ================== SEPARATE FEATURES AND TARGET ==================
X = train.drop(columns=[target_col])
y = train[target_col]

# ================== IMPUTATION ==================
numerical_cols = X.select_dtypes(include=np.number).columns.tolist()
categorical_cols = X.select_dtypes(exclude=np.number).columns.tolist()

num_imputer = SimpleImputer(strategy='median')
cat_imputer = SimpleImputer(strategy='most_frequent')
X[numerical_cols] = num_imputer.fit_transform(X[numerical_cols])
X[categorical_cols] = cat_imputer.fit_transform(X[categorical_cols])

# ================== OUTLIER REMOVAL (NO SCALER) ==================
Q1 = X[numerical_cols].quantile(0.25)
Q3 = X[numerical_cols].quantile(0.75)
IQR = Q3 - Q1
lower_bounds = Q1 - 3 * IQR
upper_bounds = Q3 + 2.1 * IQR

mask_no_outliers = ~((X[numerical_cols] < lower_bounds) | (X[numerical_cols] > upper_bounds)).any(axis=1)

# Filter y outliers using wide IQR method
Q1_y, Q3_y = y.quantile(0.10), y.quantile(0.90)
IQR_y = Q3_y - Q1_y
lower_y = Q1_y - 50 * IQR_y
upper_y = Q3_y + 125 * IQR_y
mask_y = (y >= lower_y) & (y <= upper_y)

mask = mask_no_outliers & mask_y
X = X[mask]
y = y[mask]

print(f"After outlier removal (no scaling): {len(y)} rows kept")

# ================== LABEL ENCODING ==================
label_encoders = {}
for col in categorical_cols:
    le = LabelEncoder()
    X[col] = le.fit_transform(X[col].astype(str))
    label_encoders[col] = le

# ================== LASSO REGRESSION (NO SCALER) ==================
lasso_pipeline = Pipeline([
    ('lasso', LassoCV(
        alphas=np.logspace(-4, 3, 100),
        cv=5,
        max_iter=10000,
        random_state=42
    ))
])

# ================== K-FOLD VALIDATION ==================
kf = KFold(n_splits=2, shuffle=True, random_state=42)
rmse_list, r2_list, adj_r2_list = [], [], []

n = len(X)
p = X.shape[1]

for fold, (train_idx, val_idx) in enumerate(kf.split(X), 1):
    X_train, X_val = X.iloc[train_idx], X.iloc[val_idx]
    y_train, y_val = y.iloc[train_idx], y.iloc[val_idx]

    lasso_pipeline.fit(X_train, y_train)
    y_val_pred = lasso_pipeline.predict(X_val)

    rmse = np.sqrt(mean_squared_error(y_val, y_val_pred))
    r2 = r2_score(y_val, y_val_pred)
    
    n_val = len(y_val)
    adj_r2 = 1 - (1 - r2) * ((n_val - 1) / (n_val - p - 1))

    rmse_list.append(rmse)
    r2_list.append(r2)
    adj_r2_list.append(adj_r2)

    print(f"Fold {fold}: RMSE = {rmse:.3f}, R² = {r2:.3f}, Adjusted R² = {adj_r2:.3f}")

print(f"\nAverage RMSE: {np.mean(rmse_list):.3f}")
print(f"Average R²: {np.mean(r2_list):.3f}")
print(f"Average Adjusted R²: {np.mean(adj_r2_list):.3f}")

# Best alpha from LassoCV
best_alpha = lasso_pipeline.named_steps['lasso'].alpha_
print(f"\nBest alpha selected by LassoCV: {best_alpha:.6f}")

# ================== FINAL TRAIN ON FULL DATA ==================
lasso_pipeline.fit(X, y)

# ================== LOAD TEST SET ==================
test = pd.read_csv('/kaggle/input/Medical-Equipments-Cost-Prediction-Challenge/test.csv')
hospital_ids = test['Hospital_Id'].copy()

test['Order_Placed_Date'] = pd.to_datetime(test['Order_Placed_Date'], format='%m/%d/%y', errors='coerce')
test['Delivery_Date'] = pd.to_datetime(test['Delivery_Date'], format='%m/%d/%y', errors='coerce')
test['Days_Between_Order_Delivery'] = (test['Delivery_Date'] - test['Order_Placed_Date']).dt.days

test.loc[test['Days_Between_Order_Delivery'] < 0, 'Days_Between_Order_Delivery'] = median_days
test['Days_Between_Order_Delivery'] = test['Days_Between_Order_Delivery'].fillna(median_days).astype(int)

test = test.drop(columns=drop_cols, errors='ignore')

test[numerical_cols] = num_imputer.transform(test[numerical_cols])
test[categorical_cols] = cat_imputer.transform(test[categorical_cols])

# Apply label encoders from training
for col in categorical_cols:
    le = label_encoders[col]
    test[col] = test[col].map(lambda s: s if s in le.classes_ else 'unknown')
    le_classes = np.append(le.classes_, 'unknown')
    le.classes_ = le_classes
    test[col] = le.transform(test[col].astype(str))

# Ensure test has same columns as train
test = test.reindex(columns=X.columns, fill_value=0)

# ================== PREDICTION ==================
y_pred_test = lasso_pipeline.predict(test)
pred_df = pd.DataFrame({
    'Hospital_Id': hospital_ids,
    'Transport_Cost': y_pred_test
})

print("\n===== Sample Predictions =====")
print(pred_df.head())
pred_df.to_csv('submission.csv', index=False)
print(f"\nSubmission file created with {len(pred_df)} predictions.")
